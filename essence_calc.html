<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Essence Farming Calculator</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      margin: 0;
      padding: 24px;
      min-height: 100vh;
    }
    .container { max-width: 800px; margin: 0 auto; }
    h1 { font-size: 22px; font-weight: 700; color: #feff42; margin-bottom: 4px; letter-spacing: 0.5px; }
    h2 { font-size: 16px; color: #ffffff; margin: 0; }
    h3 { font-size: 14px; color: #999999; margin-bottom: 10px; }

    label { font-size: 11px; color: #888888; text-transform: uppercase; letter-spacing: 1px; display: block; }
    select, input[type="number"] {
      width: 100%;
      padding: 8px;
      background: #111111;
      border: 1px solid #333333;
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 14px;
      margin-top: 4px;
    }
    select:focus, input[type="number"]:focus {
      outline: none;
      border-color: #feff42;
    }

    .config-grid {
      display: flex;
      gap: 24px;
      margin-bottom: 20px;
    }
    .config-grid > div {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .config-grid label {
      margin: 0;
      white-space: nowrap;
    }
    .config-grid input[type="number"] {
      width: 70px;
      margin: 0;
      -moz-appearance: textfield;
    }
    .config-grid input[type="number"]::-webkit-outer-spin-button,
    .config-grid input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .builds-section { margin-bottom: 20px; }
    .builds-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .builds-hint { font-size: 12px; color: #666666; margin-bottom: 12px; }
    .builds-list { display: flex; flex-direction: column; gap: 8px; }

    .build-row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr auto;
      gap: 8px;
      align-items: end;
      padding: 12px;
      background: #141414;
      border-radius: 8px;
      border: 1px solid #2a2a2a;
    }

    .btn-add {
      background: #1a1a0a;
      color: #feff42;
      border: 1px solid #3a3a1a;
      border-radius: 6px;
      padding: 6px 14px;
      cursor: pointer;
      font-size: 13px;
    }
    .btn-add:hover { background: #2a2a1a; border-color: #feff42; }
    .btn-remove {
      background: #1a1a1a;
      color: #888888;
      border: 1px solid #333333;
      border-radius: 6px;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 14px;
      align-self: end;
      height: fit-content;
    }
    .btn-remove:hover { color: #ff6666; border-color: #ff6666; }
    .btn-remove:disabled { background: #111111; color: #444444; border-color: #222222; cursor: not-allowed; }

    .results-box {
      background: #141414;
      border: 1px solid #2a2a2a;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .results-box h2 { margin-top: 0; margin-bottom: 16px; }

    /* Step 1: Zone selection */
    .zone-list { display: flex; flex-direction: column; gap: 6px; }
    .zone-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 6px;
      cursor: pointer;
      transition: border-color 0.15s;
    }
    .zone-item:hover { border-color: #444444; }
    .zone-item.selected { border-color: #feff42; background: #1a1a10; }
    .zone-item.invalid { opacity: 0.4; cursor: not-allowed; }
    .zone-item-name { color: #cccccc; font-size: 14px; }
    .zone-item-status { font-size: 12px; color: #888888; }
    .zone-item.invalid .zone-item-status { color: #666666; }
    .zone-item.selected .zone-item-name { color: #feff42; }

    /* Step 2: Zone details */
    .zone-details {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #2a2a2a;
    }
    .zone-details h3 { color: #ffffff; margin-top: 0; }

    .ticket-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 20px;
    }
    .ticket-header {
      display: flex;
      justify-content: space-between;
      padding: 0 12px 4px;
      font-size: 11px;
      color: #666666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .ticket-header span:first-child {
      color: #ffffff;
      font-size: 16px;
      font-weight: 700;
      text-transform: none;
      letter-spacing: 0;
    }
    .ticket-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 6px;
      cursor: pointer;
    }
    .ticket-option:hover { border-color: #444444; }
    .ticket-option.selected { border-color: #feff42; background: #1a1a10; }
    .ticket-option-name { color: #cccccc; font-size: 13px; }
    .ticket-option-prob { font-size: 13px; font-family: monospace; color: #feff42; }
    .prob-calc { color: #888888; }

    .stats-row { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 20px; }
    .stat-box {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 10px;
      padding: 16px;
      text-align: center;
      flex: 1;
      min-width: 140px;
    }
    .stat-label { font-size: 12px; color: #888888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
    .stat-value { font-size: 24px; font-weight: 700; color: #feff42; }
    .stat-sub { font-size: 12px; color: #666666; margin-top: 4px; }

    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th { text-align: left; padding: 8px 12px; color: #888888; font-weight: 600; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid #2a2a2a; }
    td { padding: 8px 12px; color: #cccccc; border-bottom: 1px solid #1a1a1a; }

    .title-row { display: flex; align-items: center; justify-content: space-between; }
    .title-row h1 { margin: 0; }
    .help-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #1a1a1a;
      border: 1px solid #333333;
      color: #888888;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .help-btn:hover { border-color: #feff42; color: #feff42; }

    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 200;
      align-items: center;
      justify-content: center;
    }
    .modal-overlay.open { display: flex; }
    .modal {
      background: #141414;
      border: 1px solid #2a2a2a;
      border-radius: 12px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal h2 { margin-top: 0; margin-bottom: 16px; }
    .modal p { font-size: 13px; color: #cccccc; line-height: 1.5; margin: 0 0 6px 0; }
    .modal p strong { display: block; margin-top: 12px; }
    .modal code {
      background: #1a1a1a;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      color: #feff42;
    }
    .modal-close {
      float: right;
      background: none;
      border: none;
      color: #888888;
      font-size: 20px;
      cursor: pointer;
    }
    .modal-close:hover { color: #ffffff; }

    .no-zones-msg { color: #ff6666; font-size: 13px; padding: 12px; background: #1a1a1a; border-radius: 6px; }

    .mode-toggle {
      display: flex;
      gap: 0;
      margin-bottom: 20px;
    }
    .mode-btn {
      flex: 1;
      padding: 10px 16px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      color: #888888;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .mode-btn:first-child { border-radius: 6px 0 0 6px; }
    .mode-btn:last-child { border-radius: 0 6px 6px 0; border-left: none; }
    .mode-btn.active {
      background: #1a1a10;
      border-color: #feff42;
      color: #feff42;
      border-left: 1px solid #feff42;
    }
    .mode-btn:not(.active):hover { border-color: #444444; color: #cccccc; }

    .plan-zone {
      background: #141414;
      border: 1px solid #2a2a2a;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 16px;
    }
    .plan-zone-name {
      color: #ffffff;
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 16px;
    }
    .plan-configs {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .plan-config {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 14px;
    }
    .plan-config-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .plan-config-ticket { color: #feff42; font-size: 13px; font-weight: 600; }
    .plan-config-prob { color: #888888; font-size: 12px; }
    .plan-config-prob span { color: #feff42; }
    .plan-essences {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }
    .plan-essence {
      background: #252525;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 12px;
      color: #cccccc;
    }
    .plan-stats {
      display: flex;
      gap: 16px;
      font-size: 12px;
      color: #888888;
    }
    .plan-stats span { color: #feff42; }
  </style>
</head>
<body>
  <div class="container">
    <div class="title-row">
      <h1>Essence Farming Calculator</h1>
      <button class="help-btn" onclick="toggleModal(true)">?</button>
    </div>
    <br>
    <div class="config-grid">
      <div>
        <label>Essences / Run</label>
        <input type="number" id="essencesPerRun" value="3" min="1">
      </div>
      <div>
        <label>Sanity / Run</label>
        <input type="number" id="sanityCost" value="80" min="1">
      </div>
    </div>

    <div class="mode-toggle">
      <button class="mode-btn active" id="modeMulti" onclick="setMode('multi')">Planner</button>
      <button class="mode-btn" id="modeSingle" onclick="setMode('single')">Calc</button>
    </div>

    <div class="builds-section">
      <div class="builds-header">
        <h2>Desired Essences</h2>
        <button class="btn-add" onclick="addBuild()">+ Add Essence</button>
      </div>
      <div class="builds-list" id="buildsList"></div>
    </div>

    <div class="results-box" id="singleModeResults" style="display: none;">
      <h2>Energy Alluvium</h2>
      <div class="zone-list" id="zoneList"></div>
      <div class="zone-details" id="zoneDetails" style="display: none;"></div>
    </div>

    <div class="results-box" id="multiModeResults">
      <h2>Farming Plan</h2>
      <div id="farmingPlan"></div>
    </div>
  </div>

  <script>
    const ZONES = {
      "the-hub": {
        name: "The Hub",
        skills: ["Assault", "Suppression", "Pursuit", "Crusher", "Combative", "Detonate", "Flow", "Efficacy"],
        secondaries: ["Attack", "Heat DMG", "Electric DMG", "Cryo DMG", "Nature DMG", "Arts Intensity", "Ultimate Gain", "Arts DMG"]
      },
      "originium-science-park": {
        name: "Originium Science Park",
        skills: ["Suppression", "Pursuit", "Inspiring", "Combative", "Infliction", "Medicant", "Fracture", "Efficacy"],
        secondaries: ["Attack", "Physical DMG", "Electric DMG", "Cryo DMG", "Nature DMG", "Critical Rate", "Ultimate Gain", "Arts DMG"]
      },
      "origin-lodespring": {
        name: "Origin Lodespring",
        skills: ["Assault", "Suppression", "Combative", "Brutality", "Infliction", "Detonate", "Twilight", "Efficacy"],
        secondaries: ["HP", "Physical DMG", "Heat DMG", "Cryo DMG", "Nature DMG", "Critical Rate", "Arts Intensity", "Treatment Efficiency"]
      },
      "power-plateau": {
        name: "Power Plateau",
        skills: ["Pursuit", "Crusher", "Inspiring", "Brutality", "Infliction", "Medicant", "Fracture", "Flow"],
        secondaries: ["Attack", "HP", "Physical DMG", "Heat DMG", "Nature DMG", "Critical Rate", "Arts Intensity", "Treatment Efficiency"]
      },
      "wuling-city": {
        name: "Wuling City",
        skills: ["Assault", "Crusher", "Brutality", "Medicant", "Fracture", "Detonate", "Twilight", "Flow"],
        secondaries: ["Attack", "HP", "Electric DMG", "Cryo DMG", "Critical Rate", "Ultimate Gain", "Arts DMG", "Treatment Efficiency"]
      }
    };

    const ATTRIBUTES = ["Agility", "Strength", "Will", "Intellect", "Main Attribute"];
    const ALL_SECONDARIES = [...new Set(Object.values(ZONES).flatMap(z => z.secondaries))].sort();
    const ALL_SKILLS = [...new Set(Object.values(ZONES).flatMap(z => z.skills))].sort();

    const ATTR_POOL = 5;
    const ATTR_TICKET_POOL = 3;

    let plannerBuilds = [
      { attribute: "Agility", secondary: "Attack", skill: "Flow" },
    ];
    let calcBuilds = [
      { attribute: "Agility", secondary: "Attack", skill: "Flow" },
    ];
    let selectedZone = null;
    let selectedTicket = "none"; // "none", "secondary", "skill"
    let currentMode = "multi"; // "single" or "multi"

    function getBuilds() {
      return currentMode === 'multi' ? plannerBuilds : calcBuilds;
    }

    function setBuilds(newBuilds) {
      if (currentMode === 'multi') {
        plannerBuilds = newBuilds;
      } else {
        calcBuilds = newBuilds;
      }
    }

    function setMode(mode) {
      currentMode = mode;
      document.getElementById('modeSingle').classList.toggle('active', mode === 'single');
      document.getElementById('modeMulti').classList.toggle('active', mode === 'multi');
      document.getElementById('singleModeResults').style.display = mode === 'single' ? 'block' : 'none';
      document.getElementById('multiModeResults').style.display = mode === 'multi' ? 'block' : 'none';
      renderBuilds();
      if (mode === 'multi') {
        calculateMultiZonePlan();
      } else {
        calculate();
      }
    }

    function getValidZonesForEssence(essence) {
      const valid = [];
      for (const [zoneId, zone] of Object.entries(ZONES)) {
        if (zone.secondaries.includes(essence.secondary) && zone.skills.includes(essence.skill)) {
          valid.push(zoneId);
        }
      }
      return valid;
    }

    function getZoneConfigurations(zoneId, essences) {
      // Returns all possible ticket configurations for a zone, each with the essences it can handle
      const zone = ZONES[zoneId];
      const secPool = zone.secondaries.length;
      const skillPool = zone.skills.length;
      const configs = [];

      // Option 1: No ticket - all essences can be farmed
      const probNoTicket = essences.length * (1 / ATTR_POOL) * (1 / secPool) * (1 / skillPool);
      configs.push({
        ticket: "none",
        stat: null,
        essences: essences,
        prob: probNoTicket
      });

      // Option 2: Secondary tickets - only essences with that secondary can be farmed
      const secGroups = {};
      essences.forEach(e => {
        if (!secGroups[e.secondary]) secGroups[e.secondary] = [];
        secGroups[e.secondary].push(e);
      });
      for (const [sec, group] of Object.entries(secGroups)) {
        // Find best 3 attributes among this group
        const attrCounts = {};
        group.forEach(e => { attrCounts[e.attribute] = (attrCounts[e.attribute] || 0) + 1; });
        const top3Attrs = Object.entries(attrCounts).sort((a,b) => b[1] - a[1]).slice(0, 3).map(x => x[0]);
        const validEssences = group.filter(e => top3Attrs.includes(e.attribute));
        if (validEssences.length > 0) {
          const prob = validEssences.length * (1 / ATTR_TICKET_POOL) * 1 * (1 / skillPool);
          configs.push({
            ticket: "secondary",
            stat: sec,
            essences: validEssences,
            prob: prob
          });
        }
      }

      // Option 3: Skill tickets - only essences with that skill can be farmed
      const skillGroups = {};
      essences.forEach(e => {
        if (!skillGroups[e.skill]) skillGroups[e.skill] = [];
        skillGroups[e.skill].push(e);
      });
      for (const [skill, group] of Object.entries(skillGroups)) {
        const attrCounts = {};
        group.forEach(e => { attrCounts[e.attribute] = (attrCounts[e.attribute] || 0) + 1; });
        const top3Attrs = Object.entries(attrCounts).sort((a,b) => b[1] - a[1]).slice(0, 3).map(x => x[0]);
        const validEssences = group.filter(e => top3Attrs.includes(e.attribute));
        if (validEssences.length > 0) {
          const prob = validEssences.length * (1 / ATTR_TICKET_POOL) * (1 / secPool) * 1;
          configs.push({
            ticket: "skill",
            stat: skill,
            essences: validEssences,
            prob: prob
          });
        }
      }

      return configs;
    }

    function calculateMultiZonePlan() {
      const builds = getBuilds();
      const essencesPerRun = getVal('essencesPerRun');
      const sanityCost = getVal('sanityCost');
      const planEl = document.getElementById('farmingPlan');

      if (builds.length === 0) {
        planEl.innerHTML = '<p class="no-zones-msg">Add essences to generate a farming plan.</p>';
        return;
      }

      // Find valid zones for each essence
      const essenceZones = builds.map((b, i) => ({
        ...b,
        index: i,
        validZones: getValidZonesForEssence(b)
      }));

      // Check for impossible essences
      const impossible = essenceZones.filter(e => e.validZones.length === 0);
      if (impossible.length > 0) {
        planEl.innerHTML = `<p class="no-zones-msg">No zone can drop: ${impossible.map(e => `${e.attribute}/${e.secondary}/${e.skill}`).join(', ')}</p>`;
        return;
      }

      // Greedy algorithm: assign essences to zones for best efficiency
      const remaining = [...essenceZones];
      const plan = []; // { zoneId, essences, ticket, stat, prob }

      while (remaining.length > 0) {
        let bestOption = null;

        // Try each zone and each ticket configuration
        for (const [zoneId, zone] of Object.entries(ZONES)) {
          const canHandle = remaining.filter(e => e.validZones.includes(zoneId));
          if (canHandle.length === 0) continue;

          const configs = getZoneConfigurations(zoneId, canHandle);

          for (const config of configs) {
            // Score: prioritize higher probability per essence
            const score = config.prob;

            if (!bestOption || score > bestOption.score) {
              bestOption = {
                zoneId,
                essences: config.essences,
                ticket: config.ticket,
                stat: config.stat,
                prob: config.prob,
                score
              };
            }
          }
        }

        if (!bestOption) break;

        plan.push(bestOption);
        // Remove assigned essences from remaining
        const assignedIndices = new Set(bestOption.essences.map(e => e.index));
        remaining.splice(0, remaining.length, ...remaining.filter(e => !assignedIndices.has(e.index)));
      }

      // Render the plan - group by zone
      if (plan.length === 0) {
        planEl.innerHTML = '<p class="no-zones-msg">Could not generate a farming plan.</p>';
        return;
      }

      // Group plan items by zone
      const byZone = {};
      plan.forEach(p => {
        if (!byZone[p.zoneId]) byZone[p.zoneId] = [];
        byZone[p.zoneId].push(p);
      });

      planEl.innerHTML = Object.entries(byZone).map(([zoneId, configs]) => {
        const zone = ZONES[zoneId];

        const configsHtml = configs.map(p => {
          const pMiss = 1 - p.prob;
          const pRunMiss = Math.pow(pMiss, essencesPerRun);
          const pRunHit = 1 - pRunMiss;
          const avgSanity = (pRunHit > 0 ? 1 / pRunHit : Infinity) * sanityCost;
          const ticketText = p.ticket === 'none' ? 'No ticket' : `Lock ${p.stat}`;

          return `
            <div class="plan-config">
              <div class="plan-config-header">
                <span class="plan-config-ticket">${ticketText}</span>
                <span class="plan-config-prob">Per essence: <span>${(p.prob * 100).toFixed(2)}%</span></span>
              </div>
              <div class="plan-essences">
                ${p.essences.map(e => `<span class="plan-essence">${e.attribute} / ${e.secondary} / ${e.skill}</span>`).join('')}
              </div>
              <div class="plan-stats">
                Per run: <span>${(pRunHit * 100).toFixed(1)}%</span> ·
                Avg sanity: <span>${Math.round(avgSanity).toLocaleString()}</span>
              </div>
            </div>
          `;
        }).join('');

        return `
          <div class="plan-zone">
            <div class="plan-zone-name">${zone.name}</div>
            <div class="plan-configs">
              ${configsHtml}
            </div>
          </div>
        `;
      }).join('');
    }

    function getVal(id) { return Math.max(1, parseInt(document.getElementById(id).value) || 1); }

    function renderBuilds() {
      const builds = getBuilds();
      const list = document.getElementById('buildsList');
      list.innerHTML = builds.map((b, i) => `
        <div class="build-row">
          <div>
            <label>Attribute</label>
            <select onchange="updateBuild(${i}, 'attribute', this.value)">
              ${ATTRIBUTES.map(a => `<option value="${a}" ${b.attribute === a ? 'selected' : ''}>${a}</option>`).join('')}
            </select>
          </div>
          <div>
            <label>Secondary</label>
            <select onchange="updateBuild(${i}, 'secondary', this.value)">
              ${ALL_SECONDARIES.map(s => `<option value="${s}" ${b.secondary === s ? 'selected' : ''}>${s}</option>`).join('')}
            </select>
          </div>
          <div>
            <label>Skill</label>
            <select onchange="updateBuild(${i}, 'skill', this.value)">
              ${ALL_SKILLS.map(s => `<option value="${s}" ${b.skill === s ? 'selected' : ''}>${s}</option>`).join('')}
            </select>
          </div>
          <button class="btn-remove" onclick="removeBuild(${i})" ${builds.length <= 1 ? 'disabled' : ''}>✕</button>
        </div>
      `).join('');
    }

    function recalculate() {
      if (currentMode === 'multi') {
        calculateMultiZonePlan();
      } else {
        calculate();
      }
    }

    function updateBuild(i, field, value) {
      getBuilds()[i][field] = value;
      selectedZone = null;
      recalculate();
    }

    function addBuild() {
      getBuilds().push({
        attribute: ATTRIBUTES[0],
        secondary: ALL_SECONDARIES[0],
        skill: ALL_SKILLS[0]
      });
      selectedZone = null;
      renderBuilds();
      recalculate();
    }

    function removeBuild(i) {
      const builds = getBuilds();
      if (builds.length > 1) {
        builds.splice(i, 1);
        selectedZone = null;
        renderBuilds();
        recalculate();
      }
    }

    function selectZone(zoneId) {
      if (!zoneId) return;
      const builds = getBuilds();
      const zone = ZONES[zoneId];
      const requiredSecs = new Set(builds.map(b => b.secondary));
      const requiredSkills = new Set(builds.map(b => b.skill));
      const hasAllSecs = [...requiredSecs].every(s => zone.secondaries.includes(s));
      const hasAllSkills = [...requiredSkills].every(s => zone.skills.includes(s));
      if (!hasAllSecs || !hasAllSkills) return;

      selectedZone = zoneId;
      selectedTicket = "none";
      calculate();
    }

    function selectTicket(ticket) {
      selectedTicket = ticket;
      calculate();
    }

    function calculate() {
      const builds = getBuilds();
      const essencesPerRun = getVal('essencesPerRun');
      const sanityCost = getVal('sanityCost');

      // Calculate zone validity
      const zoneResults = [];
      for (const [zoneId, zone] of Object.entries(ZONES)) {
        const requiredSecs = new Set(builds.map(b => b.secondary));
        const requiredSkills = new Set(builds.map(b => b.skill));
        const hasAllSecs = [...requiredSecs].every(s => zone.secondaries.includes(s));
        const hasAllSkills = [...requiredSkills].every(s => zone.skills.includes(s));
        zoneResults.push({ zoneId, zone, isValid: hasAllSecs && hasAllSkills });
      }

      // Render zone list
      document.getElementById('zoneList').innerHTML = zoneResults.map(r => `
        <div class="zone-item ${r.isValid ? '' : 'invalid'} ${selectedZone === r.zoneId ? 'selected' : ''}"
             onclick="${r.isValid ? `selectZone('${r.zoneId}')` : ''}">
          <span class="zone-item-name">${r.zone.name}</span>
          <span class="zone-item-status">${r.isValid ? 'Available' : 'Missing stats'}</span>
        </div>
      `).join('');

      // Render zone details if selected
      const detailsEl = document.getElementById('zoneDetails');
      if (!selectedZone) {
        detailsEl.style.display = 'none';
        return;
      }

      detailsEl.style.display = 'block';
      const zone = ZONES[selectedZone];

      // Calculate probabilities for each ticket option
      const secPool = zone.secondaries.length;
      const skillPool = zone.skills.length;

      // Find optimal ticket configuration
      // For each ticket type, we need to find:
      // 1. Best secondary/skill to lock (most common)
      // 2. Best 3 attributes to lock (among essences that have that secondary/skill)

      function findBestTicketConfig(builds, statKey) {
        // Group builds by the stat (secondary or skill)
        const statGroups = {};
        builds.forEach(b => {
          const stat = b[statKey];
          if (!statGroups[stat]) statGroups[stat] = [];
          statGroups[stat].push(b);
        });

        // For each stat value, find the best 3 attributes
        let bestConfig = { stats: [], attrs: [], count: 0 };

        for (const [stat, group] of Object.entries(statGroups)) {
          // Count attributes in this group
          const attrCounts = {};
          group.forEach(b => {
            attrCounts[b.attribute] = (attrCounts[b.attribute] || 0) + 1;
          });

          // Get top 3 attributes by count
          const sortedAttrs = Object.entries(attrCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([attr]) => attr);

          // Count how many essences benefit (have this stat AND one of top 3 attrs)
          const benefitCount = group.filter(b => sortedAttrs.includes(b.attribute)).length;

          if (benefitCount > bestConfig.count) {
            bestConfig = { stats: [stat], attrs: sortedAttrs, count: benefitCount };
          } else if (benefitCount === bestConfig.count && benefitCount > 0) {
            // Multiple stats give same benefit - show all
            if (!bestConfig.stats.includes(stat)) {
              bestConfig.stats.push(stat);
            }
          }
        }

        return bestConfig;
      }

      const secConfig = findBestTicketConfig(builds, 'secondary');
      const skillConfig = findBestTicketConfig(builds, 'skill');

      const probNoTicket = builds.length * (1 / ATTR_POOL) * (1 / secPool) * (1 / skillPool);
      // Secondary ticket: only essences with best secondary AND valid attribute benefit
      const probSecTicket = secConfig.count * (1 / ATTR_TICKET_POOL) * 1 * (1 / skillPool);
      // Skill ticket: only essences with best skill AND valid attribute benefit
      const probSkillTicket = skillConfig.count * (1 / ATTR_TICKET_POOL) * (1 / secPool) * 1;

      // Get current probability based on selection
      let currentP;
      if (selectedTicket === "secondary") {
        currentP = probSecTicket;
      } else if (selectedTicket === "skill") {
        currentP = probSkillTicket;
      } else {
        currentP = probNoTicket;
      }

      const pMiss = 1 - currentP;
      const pRunMiss = Math.pow(pMiss, essencesPerRun);
      const pRunHit = 1 - pRunMiss;
      const avgRuns = pRunHit > 0 ? 1 / pRunHit : Infinity;
      const avgSanity = avgRuns * sanityCost;
      const avgRegenDays = (avgSanity * 432) / 86400;

      const frac = (n) => n === 1 ? '1' : `1/${n}`;

      detailsEl.innerHTML = `
        <div class="ticket-options">
          <div class="ticket-header">
            <span>${zone.name}</span>
            <span>Per Essence</span>
          </div>
          <div class="ticket-option ${selectedTicket === 'none' ? 'selected' : ''}" onclick="selectTicket('none')">
            <span class="ticket-option-name">No ticket</span>
            <span class="ticket-option-prob"><span class="prob-calc">${frac(ATTR_POOL)} × ${frac(secPool)} × ${frac(skillPool)} =</span> ${(probNoTicket * 100).toFixed(2)}%</span>
          </div>
          <div class="ticket-option ${selectedTicket === 'secondary' ? 'selected' : ''}" onclick="selectTicket('secondary')">
            <span class="ticket-option-name">Lock ${secConfig.stats.join('/')} (${secConfig.count}/${builds.length} essences)</span>
            <span class="ticket-option-prob"><span class="prob-calc">${frac(ATTR_TICKET_POOL)} × 1 × ${frac(skillPool)} =</span> ${(probSecTicket * 100).toFixed(2)}%</span>
          </div>
          <div class="ticket-option ${selectedTicket === 'skill' ? 'selected' : ''}" onclick="selectTicket('skill')">
            <span class="ticket-option-name">Lock ${skillConfig.stats.join('/')} (${skillConfig.count}/${builds.length} essences)</span>
            <span class="ticket-option-prob"><span class="prob-calc">${frac(ATTR_TICKET_POOL)} × ${frac(secPool)} × 1 =</span> ${(probSkillTicket * 100).toFixed(2)}%</span>
          </div>
        </div>

        <div class="stats-row">
          <div class="stat-box">
            <div class="stat-label">Per Essence</div>
            <div class="stat-value">${(currentP * 100).toFixed(2)}%</div>
            <div class="stat-sub">1 in ${Math.round(1/currentP)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Per Run</div>
            <div class="stat-value">${(pRunHit * 100).toFixed(1)}%</div>
            <div class="stat-sub">1 in ${avgRuns.toFixed(1)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Sanity</div>
            <div class="stat-value">${Math.round(avgSanity).toLocaleString()}</div>
            <div class="stat-sub">${avgRegenDays.toFixed(1)} days regen</div>
          </div>
        </div>

        <table>
          <thead>
            <tr><th>Confidence</th><th>Runs</th><th>Sanity</th><th>Regen Time</th></tr>
          </thead>
          <tbody>
            ${[0.5, 0.75, 0.9, 0.95, 0.99].map(c => {
              if (pRunHit <= 0) return `<tr><td>${c*100}%</td><td>∞</td><td>∞</td><td>∞</td></tr>`;
              const runs = Math.ceil(Math.log(1 - c) / Math.log(pRunMiss));
              const sanity = runs * sanityCost;
              const days = (sanity * 432) / 86400;
              return `<tr><td>${c*100}%</td><td>${runs}</td><td>${sanity.toLocaleString()}</td><td>~${days.toFixed(1)} days</td></tr>`;
            }).join('')}
          </tbody>
        </table>
      `;
    }

    // Initialize
    renderBuilds();
    calculateMultiZonePlan();

    document.querySelectorAll('.config-grid input').forEach(input => {
      input.addEventListener('input', recalculate);
    });

    // Modal
    function toggleModal(open) {
      document.getElementById('helpModal').classList.toggle('open', open);
    }
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') toggleModal(false);
    });
  </script>

  <div class="modal-overlay" id="helpModal" onclick="toggleModal(false)">
    <div class="modal" onclick="event.stopPropagation()">
      <button class="modal-close" onclick="toggleModal(false)">&times;</button>
      <h2>Math</h2>
      <p><strong>Per-Essence Probability</strong></p>
      <p>Each essence rolls independently for attribute, secondary, and skill:</p>
      <p><code>P_essence = (1/attr_pool) × (1/sec_pool) × (1/skill_pool)</code></p>
      <p>If you have multiple desired essences, their probabilities add up because each roll can only match one target at a time—these are mutually exclusive outcomes.</p>

      <p><strong>Per-Run Probability</strong></p>
      <p>Each run gives you multiple essences. The chance of getting at least one match:</p>
      <p><code>P_run = 1 − (1 − P_essence)^essences_per_run</code></p>

      <p><strong>Confidence Levels</strong></p>
      <p>How many runs to reach X% confidence of getting at least one match:</p>
      <p><code>Runs = ⌈ln(1 − confidence) / ln(1 − P_run)⌉</code></p>

      <p><strong>Sanity Regen</strong></p>
      <p>1 sanity regenerates every 7 minutes and 12 seconds</p>
    </div>
  </div>
</body>
</html>
